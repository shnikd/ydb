# Serial Types

Serial types are integer types with an associated value-generation mechanism. These types are used to create auto-increment columns: for each new row inserted into a table, a unique value for this column is generated automatically (similar to the [SERIAL](https://www.postgresql.org/docs/current/datatype-numeric.html#DATATYPE-SERIAL) type in PostgreSQL or the [AUTO_INCREMENT](https://dev.mysql.com/doc/refman/9.0/en/example-auto-increment.html) property in MySQL).

## Description

When a column of a serial type is defined, a separate schema object called a `Sequence` is created and bound to this column. This object is a private sequence generator and it is hidden from the user. The `Sequence` will be destroyed together with the table.

The `Sequence` object supports several parameters that determine its behavior. These parameters can be altered after creation using the [ALTER SEQUENCE](../syntax/alter-sequence.md) command.

By default, values generated by the `Sequence` start from one, are incremented by one with each new value, and are limited according to the chosen type.

{% note info %}

Serial columns are supported both for columns included in the primary key and for non-key columns.

However, such columns cannot be [altered](../syntax/alter_table/family#mod-column-groups) or [dropped](../syntax/alter_table/columns.md) from the table — attempting to perform these operations will result in an error.

{% endnote %}

| Type        | Maximum Value         | YDB Type |
|-------------|----------------------|----------|
| SmallSerial | 2^15–1                | Int16    |
| Serial2     | 2^15–1                | Int16    |
| Serial      | 2^31–1                | Int32    |
| Serial4     | 2^31–1                | Int32    |
| Serial8     | 2^63–1                | Int64    |
| BigSerial   | 2^63–1                | Int64    |

If the sequence reaches its maximum value, insertion will result in an error:

```text
Error: Failed to get next val for sequence: /dev/test/users/_serial_column_user_id, status: SCHEME_ERROR
    <main>: Error: sequence [OwnerId: <some>, LocalPathId: <some>] doesn't have any more values available, code: 200503
```

{% note info %}

The next value is allocated by the generator before the actual insertion into the table and is considered used even if the row is not successfully inserted (for example, in case of transaction rollback).
As a result, the values in such a column may have gaps and may not form a continuous sequence.

{% endnote %}

Tables with `Serial` columns support [copy](../../../reference/ydb-cli/tools-copy.md), [rename](../../../reference/ydb-cli/commands/tools/rename.md), [dump](../../../reference/ydb-cli/export-import/tools-dump.md), [restore](../../../reference/ydb-cli/export-import/import-file.md), and [import](../../../reference/ydb-cli/export-import/import-s3.md)/[export](../../../reference/ydb-cli/export-import/export-s3.md) operations.

## Usage Example

You should carefully choose the columns for your [PRIMARY KEY](../../../dev/primary-key/row-oriented.md). For scalability and high performance, you should avoid writing rows with monotonically increasing primary keys. In this case, all records will go to the last partition, and all the load will target a single server.

As a recommended approach, use a hash (for example, from the whole or a part of the primary key) as the first key element, which will help evenly distribute data across cluster partitions.

```yql
CREATE TABLE users (
    user_hash Uint64,
    user_id Serial,
    name Utf8,
    email Utf8,
    PRIMARY KEY (user_hash, user_id)
);
```

The `user_hash` field can be calculated on the application side, for example, by applying a hash function to the `email`.

``` yql
UPSERT INTO users (user_hash, name, email) VALUES (123456789, 'Alice', 'alice@example.com');
INSERT INTO users (user_hash, name, email) VALUES (987654321, 'Bob', 'bob@example.com');
REPLACE INTO users (user_hash, name, email) VALUES (111111111, 'John', 'john@example.com');
```

Result (example `user_hash` values are used):

| user_hash   | email                 | name  | user_id |
|-------------|-----------------------|-------|---------|
| 123456789   | `alice@example.com`   | Alice | 1       |
| 987654321   | `bob@example.com`     | Bob   | 2       |
| 111111111   | `john@example.com`    | John  | 3       |

You can also explicitly specify a value for the `Serial` column during insertion, for example, when restoring data. In this case, the insertion will work like with a regular integer column, and the `Sequence` will not be affected:

``` yql
UPSERT INTO users (user_hash, user_id, name, email) VALUES (222222222, 10, 'Peter', 'peter@example.com');
```

### Suboptimal Schema Example

```yql
CREATE TABLE users_bad (
    user_id Serial,
    name Utf8,
    email Utf8,
    PRIMARY KEY (user_id)
);
```

In this example, the auto-increment column is the first and only element of the primary key. This leads to an uneven load and a bottleneck on the last partition.
